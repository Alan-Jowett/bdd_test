<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BDD Expression Converter: include/dag_walker.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">BDD Expression Converter<span id="projectnumber">&#160;main</span>
   </div>
   <div id="projectbrief">A comprehensive Binary Decision Diagram (BDD) conversion tool</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dag_walker.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Generic template for walking DAG (Directed Acyclic Graph) and tree structures.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="graph__iterator__concepts_8hpp_source.html">graph_iterator_concepts.hpp</a>&quot;</code><br />
</div>
<p><a href="dag__walker_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdag__walker_1_1_node_info.html">dag_walker::NodeInfo&lt; Iterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the current node during traversal.  <a href="structdag__walker_1_1_node_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdag__walker_1_1_edge_info.html">dag_walker::EdgeInfo&lt; Iterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect all edges (parent-child relationships) from a DAG or tree structure.  <a href="structdag__walker_1_1_edge_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptdag__walker_1_1_dag_walker_iterator.html">dag_walker::DagWalkerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept defining the required interface for DAG walker iterators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptdag__walker_1_1has__should__process.html">dag_walker::has_should_process</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept to detect if an iterator has a should_process method. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptdag__walker_1_1_visitor.html">dag_walker::Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept defining the required interface for visitor functions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23fcf8be1fd1b691b3130c48ab34b0fe" id="r_a23fcf8be1fd1b691b3130c48ab34b0fe"><td class="memTemplParams" colspan="2">template&lt;DagWalkerIterator Iterator, Visitor&lt; Iterator &gt; V&gt; </td></tr>
<tr class="memitem:a23fcf8be1fd1b691b3130c48ab34b0fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdag__walker_1_1_node_info.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dag__walker_8hpp.html#a23fcf8be1fd1b691b3130c48ab34b0fe">dag_walker::walk_dag_topological_order</a> (<a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;<a class="el" href="structdag__walker_1_1_node_info.html">root_iterator</a>, <a class="el" href="structdag__walker_1_1_node_info.html">V</a> &amp;&amp;<a class="el" href="structdag__walker_1_1_node_info.html">visitor</a>)</td></tr>
<tr class="memdesc:a23fcf8be1fd1b691b3130c48ab34b0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk a DAG in weak topological order using a visitor pattern.  <br /></td></tr>
<tr class="separator:a23fcf8be1fd1b691b3130c48ab34b0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b986a5af0e7a7c0eea4dd354311332" id="r_aa5b986a5af0e7a7c0eea4dd354311332"><td class="memTemplParams" colspan="2">template&lt;DagWalkerIterator Iterator&gt; </td></tr>
<tr class="memitem:aa5b986a5af0e7a7c0eea4dd354311332"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Iterator &gt;, std::vector&lt; <a class="el" href="structdag__walker_1_1_edge_info.html">EdgeInfo</a>&lt; Iterator &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dag__walker_8hpp.html#aa5b986a5af0e7a7c0eea4dd354311332">dag_walker::collect_nodes_and_edges_topological</a> (<a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;<a class="el" href="structdag__walker_1_1_node_info.html">root_iterator</a>)</td></tr>
<tr class="memdesc:aa5b986a5af0e7a7c0eea4dd354311332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect nodes and edges from a DAG or tree in weak topological order.  <br /></td></tr>
<tr class="separator:aa5b986a5af0e7a7c0eea4dd354311332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016448d758a8f5a5977dc4640657555d" id="r_a016448d758a8f5a5977dc4640657555d"><td class="memTemplParams" colspan="2">template&lt;DagWalkerIterator Iterator&gt; </td></tr>
<tr class="memitem:a016448d758a8f5a5977dc4640657555d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdag__walker_1_1_node_info.html">size_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="dag__walker_8hpp.html#a016448d758a8f5a5977dc4640657555d">dag_walker::count_nodes_topological</a> (<a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;<a class="el" href="structdag__walker_1_1_node_info.html">root_iterator</a>)</td></tr>
<tr class="memdesc:a016448d758a8f5a5977dc4640657555d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of nodes reachable from a root in weak topological order.  <br /></td></tr>
<tr class="separator:a016448d758a8f5a5977dc4640657555d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic template for walking DAG (Directed Acyclic Graph) and tree structures. </p>
<p>This header provides a pure iterator-based template system for traversing tree and DAG structures. The iterator represents both the current node and the traversal logic, making it suitable for various operations beyond just visualization.</p>
<p>The walker supports both tree and DAG structures using a visitor pattern approach, properly handling cycles and shared nodes by tracking visited nodes.</p>
<dl class="section author"><dt>Author</dt><dd>Alan Jowett </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2025 Alan Jowett. Licensed under the MIT License </dd></dl>

<p class="definition">Definition in file <a class="el" href="dag__walker_8hpp_source.html">dag_walker.hpp</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa5b986a5af0e7a7c0eea4dd354311332" name="aa5b986a5af0e7a7c0eea4dd354311332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b986a5af0e7a7c0eea4dd354311332">&#9670;&#160;</a></span>collect_nodes_and_edges_topological()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DagWalkerIterator Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; Iterator &gt;, std::vector&lt; EdgeInfo&lt; Iterator &gt; &gt; &gt; dag_walker::collect_nodes_and_edges_topological </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>root_iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect nodes and edges from a DAG or tree in weak topological order. </p>
<p>This performs a single traversal and returns both the list of nodes (in topological order) and the list of edges (parent-&gt;child) discovered while visiting parents. This avoids doing two separate traversals when callers need both nodes and edges.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The iterator type that represents tree/DAG nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_iterator</td><td>The root iterator to start traversal from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of (nodes vector, edges vector) </dd></dl>

<p class="definition">Definition at line <a class="el" href="dag__walker_8hpp_source.html#l00192">192</a> of file <a class="el" href="dag__walker_8hpp_source.html">dag_walker.hpp</a>.</p>

</div>
</div>
<a id="a016448d758a8f5a5977dc4640657555d" name="a016448d758a8f5a5977dc4640657555d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016448d758a8f5a5977dc4640657555d">&#9670;&#160;</a></span>count_nodes_topological()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DagWalkerIterator Iterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t dag_walker::count_nodes_topological </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>root_iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of nodes reachable from a root in weak topological order. </p>
<p>This helper walks the DAG using the existing topological walker and increments a counter for each node that would be processed. It respects the <code>should_process()</code> filtering if provided by the iterator and uses the centralized traversal logic (cycle detection, visitation tracking).</p>
<p>Using this avoids allocating and filling a vector when callers only need the total number of nodes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The iterator type that represents tree/DAG nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_iterator</td><td>The root iterator to start traversal from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t Number of nodes processed/collected </dd></dl>

<p class="definition">Definition at line <a class="el" href="dag__walker_8hpp_source.html#l00231">231</a> of file <a class="el" href="dag__walker_8hpp_source.html">dag_walker.hpp</a>.</p>

</div>
</div>
<a id="a23fcf8be1fd1b691b3130c48ab34b0fe" name="a23fcf8be1fd1b691b3130c48ab34b0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fcf8be1fd1b691b3130c48ab34b0fe">&#9670;&#160;</a></span>walk_dag_topological_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;DagWalkerIterator Iterator, Visitor&lt; Iterator &gt; V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void dag_walker::walk_dag_topological_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdag__walker_1_1_node_info.html">const</a> Iterator &amp;&#160;</td>
          <td class="paramname"><em>root_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdag__walker_1_1_node_info.html">V</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk a DAG in weak topological order using a visitor pattern. </p>
<p>This function traverses a tree or DAG structure in weak topological order, ensuring that each node is visited after all its dependencies (children) have been processed. This is useful for operations like dependency resolution, bottom-up computation, or post-order processing.</p>
<p>The traversal order guarantees that:</p><ul>
<li>Leaf nodes (no children) are visited first</li>
<li>Each node is visited only after all its children have been visited</li>
<li>Shared nodes in DAGs are visited only once, after all paths to them complete</li>
</ul>
<p>Required iterator interface:</p><ul>
<li>std::vector&lt;Iterator&gt; get_children() const</li>
<li>const void* get_node_address() const (for unique node identification)</li>
</ul>
<p>Optional filtering:</p><ul>
<li>bool should_process() const (defaults to true if not provided)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>The iterator type that represents tree/DAG nodes </td></tr>
    <tr><td class="paramname">V</td><td>A callable that accepts NodeInfo&lt;Iterator&gt;&amp; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_iterator</td><td>The root iterator to start traversal from </td></tr>
    <tr><td class="paramname">visitor</td><td>Function called for each node during traversal</td></tr>
  </table>
  </dd>
</dl>
<p>@requires Iterator must satisfy DagWalkerIterator concept @requires V must satisfy Visitor&lt;V, Iterator&gt; concept </p>

<p class="definition">Definition at line <a class="el" href="dag__walker_8hpp_source.html#l00102">102</a> of file <a class="el" href="dag__walker_8hpp_source.html">dag_walker.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
